import os
import time
import yaml
from pathlib import Path

from settings import Settings
from csvReader import CsvReader


class MyDumper(yaml.SafeDumper):
    # HACK: insert blank lines between top-level objects
    # source: https://github.com/yaml/pyyaml/issues/127
    # inspired by https://stackoverflow.com/a/44284819/3786245
    def write_line_break(self, data=None):
        super().write_line_break(data)

        if len(self.indents) == 1:
            super().write_line_break()


class Generator:
    __instance = None
    __result = {}

    def instance() -> "Generator":
        if Generator.__instance is None:
            Generator.__instance = Generator()

        return Generator.__instance

    def __init__(self) -> None:
        if Generator.__instance is not None:
            raise Exception("Sorry, call Generator.instance()")

        # singleton
        Generator.__instance = self

    def run(self) -> None:
        # read generator file
        with open(Settings.instance().path_generator, "r") as file:
            generator = yaml.safe_load(file)

        # handle entries
        for key in generator:
            match key.lower():
                case "light":
                    for rule in generator[key]:
                        self.__handleLightRule(key.lower(), rule)

                case "switch":
                    for rule in generator[key]:
                        self.__handleSwitchRule(key.lower(), rule)

                case "binary_sensor":
                    for rule in generator[key]:
                        self.__handleBinarySensorRule(key.lower(), rule)

                case "sensor":
                    for rule in generator[key]:
                        self.__handleSensorRule(key.lower(), rule)

                case "cover":
                    for rule in generator[key]:
                        self.__handleCoverRule(key.lower(), rule)

                case _:
                    print("Found invalid key in generator file: " + key)
                    continue

        # read add_entries and add it to the result
        addEntitiesPath = Settings.instance().path_add_entities
        if addEntitiesPath is not None and addEntitiesPath != "" and os.path.isfile(addEntitiesPath):
            with open(addEntitiesPath, "r") as file:
                addEntries = yaml.safe_load(file)

            if addEntries is not None:
                for key in addEntries:
                    if key not in self.__result:
                        self.__result[key] = []
                    self.__result[key] += addEntries[key]

    def saveResult(self) -> None:
        targetPath = Settings.instance().path_output

        # Make backup if target file exists
        if os.path.isfile(targetPath):
            backupPath = os.path.join(Settings.instance().path_backup, Path(targetPath).stem + "_" + time.strftime("%Y-%m-%d_%H%M%S") + Path(targetPath).suffix)
            os.rename(targetPath, backupPath)

        # write target file
        with open(targetPath, "w") as file:
            file.writelines([
                "# DO NOT EDIT THIS FILE\n",
                "#\n",
                "# This file is generated by the Home Assistant Addon \"KNX YAML Generator\"\n",
                "# It will be overwritten when running the addon.\n",
                "# Don't forget to reload the yaml configurations in Home Assistant after recreating.\n",
                "#\n",
                "# DO NOT EDIT THIS FILE\n\n",
            ])
            yaml.dump(self.__result, file, Dumper=MyDumper, allow_unicode=True, sort_keys=False)

    def __handleLightRule(self, key: str, rule) -> None:
        addressItems = CsvReader.instance().query(rule.get("grp", None), rule.get("address", None), rule.get("address_ignore", None))
        addressStateItems = CsvReader.instance().query(rule.get("grp", None), rule.get("state_address", None), rule.get("state_address_ignore", None))

        self.__addToResult(
            [
                {
                    "data": addressItems,
                    "required": True,
                    "name": "address"
                },
                {
                    "data": addressStateItems,
                    "required": True,
                    "name": "state_address"
                }
            ], key
        )

    def __handleSwitchRule(self, key: str, rule) -> None:
        addressItems = CsvReader.instance().query(rule.get("grp", None), rule.get("address", None), rule.get("address_ignore", None))
        addressStateItems = CsvReader.instance().query(rule.get("grp", None), rule.get("state_address", None), rule.get("state_address_ignore", None))

        self.__addToResult(
            [
                {
                    "data": addressItems,
                    "required": True,
                    "name": "address"
                },
                {
                    "data": addressStateItems,
                    "required": True,
                    "name": "state_address"
                },
                {
                    "name": "device_class",
                    "data": "outlet"
                }
            ], key
        )

    def __handleBinarySensorRule(self, key: str, rule) -> None:
        addressStateItems = CsvReader.instance().query(rule.get("grp", None), rule.get("state_address", None), rule.get("state_address_ignore", None))

        self.__addToResult(
            [
                {
                    "data": addressStateItems,
                    "required": True,
                    "name": "state_address"
                }
            ], key
        )

    def __handleSensorRule(self, key: str, rule) -> None:
        addressStateItems = CsvReader.instance().query(rule.get("grp", None), rule.get("state_address", None), rule.get("state_address_ignore", None))

        self.__addToResult(
            [
                {
                    "data": addressStateItems,
                    "required": True,
                    "name": "state_address"
                },
                {
                    "name": "type",
                    "data": rule["type"]
                }
            ], key
        )

    def __handleCoverRule(self, key: str, rule) -> None:
        moveLongItems = CsvReader.instance().query(rule.get("grp", None), rule.get("move_long_address", None), rule.get("move_long_address_ignore", None))
        moveShortItems = CsvReader.instance().query(rule.get("grp", None), rule.get("move_short_address", None), rule.get("move_short_address_ignore", None))
        stopItems = CsvReader.instance().query(rule.get("grp", None), rule.get("stop_address", None), rule.get("stop_address_ignore", None))
        positionItems = CsvReader.instance().query(rule.get("grp", None), rule.get("position_address", None), rule.get("position_address_ignore", None))
        positionStateItems = CsvReader.instance().query(rule.get("grp", None), rule.get("position_state_address", None), rule.get("position_state_address_ignore", None))

        # remove all items from long items that are also in short items
        moveLongItems = [i for i in moveLongItems if i not in moveShortItems]

        self.__addToResult(
            [
                {
                    "data": moveLongItems,
                    "required": True,
                    "name": "move_long_address"
                },
                {
                    "data": moveShortItems,
                    "required": False,
                    "name": "move_short_address"
                },
                {
                    "data": stopItems,
                    "required": True,
                    "name": "stop_address"
                },
                {
                    "data": positionItems,
                    "required": True,
                    "name": "position_address"
                },
                {
                    "data": positionStateItems,
                    "required": True,
                    "name": "position_state_address"
                },
            ], key
        )

    def __addToResult(self, datas, key) -> None:
        tempResult = {}

        for dataItem in datas:
            if isinstance(dataItem["data"], list):
                for item in dataItem["data"]:
                    if item.matchName not in tempResult:
                        tempResult[item.matchName] = {
                            "name": item.matchName
                        }

                    tempResult[item.matchName][dataItem["name"]] = item.address

        # Add constant values to items
        for dataItem in datas:
            if isinstance(dataItem["data"], str):
                for matchName in tempResult:
                    tempResult[matchName][dataItem["name"]] = dataItem["data"]

        # Put all complete items to result
        result = []

        for matchName in tempResult:
            complete = True
            for dataItem in datas:
                if isinstance(dataItem["data"], list):
                    if dataItem["required"] and dataItem["name"] not in tempResult[matchName]:
                        complete = False
                        break

            if complete:
                result.append(tempResult[matchName])

        if len(result) > 0:
            if key not in self.__result:
                self.__result[key] = []

            self.__result[key] += result
